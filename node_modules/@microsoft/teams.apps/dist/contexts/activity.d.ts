import { Activity, ActivityLike, ConversationReference, InvokeResponse, SentActivity, TokenExchangeResource, TokenPostResource } from '@microsoft/teams.api';
import { ILogger } from '@microsoft/teams.common/logging';
import { IStorage } from '@microsoft/teams.common/storage';
import { ApiClient, GraphClient } from '../api';
import { ISender, IStreamer } from '../types';
export interface IActivityContextOptions<T extends Activity = Activity> {
    /**
     * the app id of the bot
     */
    appId: string;
    /**
     * the inbound activity
     */
    activity: T;
    /**
     * the inbound activity conversation reference
     */
    ref: ConversationReference;
    /**
     * the app logger instance
     */
    log: ILogger;
    /**
     * the api client
     */
    api: ApiClient;
    /**
     * the app graph client
     */
    appGraph: GraphClient;
    /**
     * the user graph client
     */
    userGraph: GraphClient;
    /**
     * app storage instance
     */
    storage: IStorage;
    /**
     * whether the user has provided
     * their MSGraph credentials for use
     * via `api.user.*`
     */
    isSignedIn?: boolean;
    /**
     * the default connection name to use for the app
     * @default `graph`
     */
    connectionName: string;
    /**
     * extra data
     */
    [key: string]: any;
    /**
     * call the next event/middleware handler
     */
    next: (context?: IActivityContext) => (void | InvokeResponse) | Promise<void | InvokeResponse>;
}
type SignInOptions = {
    /**
     * The text to display on the oauth card
     * @default `Please Sign In...`
     */
    oauthCardText: string;
    /**
     * The text to display on the sign in button
     * @default `Sign In`
     */
    signInButtonText: string;
    /**
     * Construct your own sign in activity
     * By default, we create a simple oauth card with a sign in button.
     * Only use this if you need to fully customize the sign in experience.
     */
    overrideSignInActivity?: (tokenExchangeResource?: TokenExchangeResource, tokenPostResource?: TokenPostResource, signInLink?: string) => ActivityLike;
};
export interface IActivityContext<T extends Activity = Activity> extends IActivityContextOptions<T> {
    /**
     * a stream that can emit activity chunks
     */
    stream: IStreamer;
    /**
     * send an activity to the conversation
     * @param activity activity to send
     */
    send: (activity: ActivityLike) => Promise<SentActivity>;
    /**
     * reply to the inbound activity
     * @param activity activity to send
     */
    reply: (activity: ActivityLike) => Promise<SentActivity>;
    /**
     * trigger user signin flow for the activity sender
     * @param options options for the signin flow
     */
    signin: (options?: Partial<SignInOptions>) => Promise<string | undefined>;
    /**
     * sign the activity sender out
     * @param name auth connection name, defaults to `graph`
     */
    signout: (name?: string) => Promise<void>;
}
export declare const DEFAULT_SIGNIN_OPTIONS: SignInOptions;
export declare class ActivityContext<T extends Activity = Activity> implements IActivityContext<T> {
    appId: string;
    activity: T;
    ref: ConversationReference;
    log: ILogger;
    api: ApiClient;
    appGraph: GraphClient;
    userGraph: GraphClient;
    storage: IStorage;
    stream: IStreamer;
    isSignedIn?: boolean;
    connectionName: string;
    next: (context?: IActivityContext) => (void | InvokeResponse) | Promise<void | InvokeResponse>;
    [key: string]: any;
    protected _plugin: ISender;
    protected _next?: (context?: IActivityContext) => (void | InvokeResponse) | Promise<void | InvokeResponse>;
    constructor(plugin: ISender, value: IActivityContextOptions);
    send(activity: ActivityLike): Promise<SentActivity>;
    reply(activity: ActivityLike): Promise<SentActivity>;
    signin(options?: Partial<SignInOptions>): Promise<string | undefined>;
    signout(): Promise<void>;
    toInterface(): IActivityContext;
    private buildBlockQuoteForActivity;
}
export {};
