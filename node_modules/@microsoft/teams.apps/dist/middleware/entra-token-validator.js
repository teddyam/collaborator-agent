"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntraTokenValidator = exports.getJwksClient = void 0;
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const jwks_rsa_1 = __importDefault(require("jwks-rsa"));
const getJwksClient = (options) => (0, jwks_rsa_1.default)(options);
exports.getJwksClient = getJwksClient;
/**
 * And Entra token validator that can validate access tokens issued by Microsoft Entra for app specific use.
 */
class EntraTokenValidator {
    tenantId;
    clientId;
    validIssuerTenantIds;
    keyClient;
    constructor({ tenantId, clientId, options }) {
        this.tenantId = tenantId;
        this.clientId = clientId;
        // single-tenant applications only allow tokens issued by this app's tenant
        // multi tenant applications allow tokens issued by any tenant, unless the
        // allowedTenantIds option is provided to limit the set of allowed issuers.
        const isMultiTenant = ['common', 'organizations', 'consumers'].some((val) => tenantId === val);
        this.validIssuerTenantIds = isMultiTenant ? options?.allowedTenantIds ?? [] : [this.tenantId];
        this.keyClient = (0, exports.getJwksClient)({
            jwksUri: `https://login.microsoftonline.com/${tenantId}/discovery/v2.0/keys`,
        });
    }
    /**
     * Validates a JWT access token
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken The access token as a string.
     * @param { string | undefined } requiredScope If provided, the token will only be considered valid if issued for this scope.
     * @returns {Promise<jwt.Jwt | null>} The validated token if the signature is valid and the claims are valid.
     */
    async validateAccessToken(logger, rawAccessToken, requiredScope) {
        if (!rawAccessToken) {
            logger.error('No token provided');
            return null;
        }
        const token = this.decodeToken(logger, rawAccessToken);
        if (!token) {
            logger.error('Failed to decode the access token');
            return null;
        }
        const publicKey = await this.getPublicKey(logger, token.header);
        if (!publicKey) {
            logger.error(`Failed to find public key for the key identifier "${token.header.kid}"`);
            return null;
        }
        const validatedToken = this.validateTokenSignature(logger, rawAccessToken, publicKey);
        if (!validatedToken) {
            logger.error('Failed to validate the token signature');
            return null;
        }
        if (!this.validateAccessTokenClaims(logger, validatedToken, requiredScope)) {
            logger.error('Failed to validate the access token claims');
            return null;
        }
        return validatedToken;
    }
    getTokenPayload(token) {
        return token.payload instanceof Object ? token.payload : null;
    }
    /**
     * Validates the token claims: that it's valid for the intended purpose, it's not expired, it has the right audience & issuer,
     * it's issued for the requisite scope.
     * @param {ILogger} logger The logger to use.
     * @param {jwt.Jwt} token The token to validate.
     * @param { string | undefined } requiredScope If provided, the token will only be considered valid if issued for this scope.
     * @returns {boolean} True if the claims validation passed.
     */
    validateAccessTokenClaims(logger, token, requiredScope) {
        const payload = this.getTokenPayload(token);
        if (!payload) {
            logger.error('Invalid token payload.');
            return false;
        }
        // validate iat (issued at) and exp (expiration) fields.
        // these are expressed as number of seconds since Unix epoch.
        const now = Math.round(new Date().getTime() / 1000.0);
        const checkTimestamp = payload.iat && payload.iat <= now && payload.exp && payload.exp >= now;
        if (!checkTimestamp) {
            logger.error('The token is expired or not yet valid.');
            return false;
        }
        // validate audience
        const checkAudience = payload.aud === this.clientId || payload.aud === `api://${this.clientId}`;
        if (!checkAudience) {
            logger.error('The token is not issued for the expected audience.');
            return false;
        }
        const tokenIssuer = payload.iss;
        if (!tokenIssuer) {
            logger.error('Invalid token issuer.');
            return false;
        }
        // validate token issuer
        //  - if this is a single-tenant application, validate that the token is issued by the expected tenant
        //  - if this is a multi-tenant application that only allows sign-in from specific tenants, validate that
        //    the token is issued by one of those
        //  - if this is a multi-tenant that does not limit sign-in to specific tenants, any issuer is considered valid.
        const checkIssuer = !this.validIssuerTenantIds.length ||
            this.validIssuerTenantIds.some((tenantId) => tokenIssuer.startsWith(`https://login.microsoftonline.com/${tenantId}/`));
        if (!checkIssuer) {
            logger.error(`The token is issued by unexpected tenant: ${payload.iss}`);
            return false;
        }
        // validate that the token is issued for the required scope
        const checkRequiredScope = !requiredScope || payload.scp?.includes(requiredScope);
        if (!checkRequiredScope) {
            logger.error(`The token is not issued for the required scope: ${requiredScope}`);
            return false;
        }
        // all checks passed
        return true;
    }
    /**
     * Decodes an access token without verifying if the signature is valid.
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken the raw access token.
     * @returns {jwt.JWT | null} A decoded token if the raw access token is well formed.
     */
    decodeToken(logger, rawAccessToken) {
        try {
            return jsonwebtoken_1.default.decode(rawAccessToken, { complete: true });
        }
        catch (error) {
            logger.error(error);
            return null;
        }
    }
    /**
     * Gets the public key from the key identifier in a token header
     * @param {ILogger} logger The logger to use.
     * @param {jwt.JwtHeader} header the token header
     * @returns {Promise<string | undefined>} the public key corresponding to the header key identifier, if available
     */
    async getPublicKey(logger, header) {
        try {
            const signingKey = await this.keyClient.getSigningKey(header.kid);
            return signingKey.getPublicKey() ?? null;
        }
        catch (error) {
            logger.error(error);
            return null;
        }
    }
    /**
     * Decodes the access token and verifies it against the public key
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken the raw access token.
     * @param {string} publicKey the public key to verify signature against.
     * @returns {Promise<jwt.JWT | null>} A decoded token if the raw token is well formed and the signature is valid.
     */
    validateTokenSignature(logger, rawAccessToken, publicKey) {
        try {
            return jsonwebtoken_1.default.verify(rawAccessToken, publicKey, { complete: true });
        }
        catch (error) {
            logger.error(error);
            return null;
        }
    }
}
exports.EntraTokenValidator = EntraTokenValidator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50cmEtdG9rZW4tdmFsaWRhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21pZGRsZXdhcmUvZW50cmEtdG9rZW4tdmFsaWRhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdFQUFvRDtBQUNwRCx3REFBa0Q7QUF5QjNDLE1BQU0sYUFBYSxHQUFHLENBQUMsT0FBMkIsRUFBYyxFQUFFLENBQUMsSUFBQSxrQkFBVSxFQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQWpGLFFBQUEsYUFBYSxpQkFBb0U7QUFFOUY7O0dBRUc7QUFDSCxNQUFhLG1CQUFtQjtJQUNyQixRQUFRLENBQVM7SUFDakIsUUFBUSxDQUFTO0lBQ2pCLG9CQUFvQixDQUFXO0lBQ2hDLFNBQVMsQ0FBYTtJQUU5QixZQUFZLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQTZCO1FBQ3BFLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1FBRXpCLDJFQUEyRTtRQUMzRSwwRUFBMEU7UUFDMUUsMkVBQTJFO1FBQzNFLE1BQU0sYUFBYSxHQUFHLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFFBQVEsS0FBSyxHQUFHLENBQUMsQ0FBQztRQUMvRixJQUFJLENBQUMsb0JBQW9CLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5RixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUEscUJBQWEsRUFBQztZQUM3QixPQUFPLEVBQUUscUNBQXFDLFFBQVEsc0JBQXNCO1NBQzdFLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFL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