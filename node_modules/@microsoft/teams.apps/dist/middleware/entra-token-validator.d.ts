import jwt, { type JwtPayload } from 'jsonwebtoken';
import jwksClient, { JwksClient } from 'jwks-rsa';
import { ILogger } from '@microsoft/teams.common';
/**
 * Entra token validator parameters
 */
type EntraTokenValidatorParams = {
    /**
     *  App tenant ID. Used to find public keys to validate token signature, and to validate issuer for single-tenant apps.
     *  This can be 'common', 'organization', or 'consumers' for a multi-tenant app, or a specific tenant ID for a single-tenant app.
     */
    tenantId: string;
    /** App client ID. Used to validate token audience. */
    clientId: string;
    options?: {
        /**
         * For multi-tenant apps that only allows sign-in from specific tenants, this is the list of allowed tenant IDs.
         * If empty or not provided, any tenant is considered valid.
         * This is ignored for single-tenant apps.
         */
        allowedTenantIds?: string[];
    };
};
export declare const getJwksClient: (options: jwksClient.Options) => JwksClient;
/**
 * And Entra token validator that can validate access tokens issued by Microsoft Entra for app specific use.
 */
export declare class EntraTokenValidator {
    readonly tenantId: string;
    readonly clientId: string;
    readonly validIssuerTenantIds: string[];
    private keyClient;
    constructor({ tenantId, clientId, options }: EntraTokenValidatorParams);
    /**
     * Validates a JWT access token
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken The access token as a string.
     * @param { string | undefined } requiredScope If provided, the token will only be considered valid if issued for this scope.
     * @returns {Promise<jwt.Jwt | null>} The validated token if the signature is valid and the claims are valid.
     */
    validateAccessToken(logger: ILogger, rawAccessToken: string, requiredScope?: string): Promise<jwt.Jwt | null>;
    getTokenPayload(token: jwt.Jwt): JwtPayload | null;
    /**
     * Validates the token claims: that it's valid for the intended purpose, it's not expired, it has the right audience & issuer,
     * it's issued for the requisite scope.
     * @param {ILogger} logger The logger to use.
     * @param {jwt.Jwt} token The token to validate.
     * @param { string | undefined } requiredScope If provided, the token will only be considered valid if issued for this scope.
     * @returns {boolean} True if the claims validation passed.
     */
    private validateAccessTokenClaims;
    /**
     * Decodes an access token without verifying if the signature is valid.
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken the raw access token.
     * @returns {jwt.JWT | null} A decoded token if the raw access token is well formed.
     */
    private decodeToken;
    /**
     * Gets the public key from the key identifier in a token header
     * @param {ILogger} logger The logger to use.
     * @param {jwt.JwtHeader} header the token header
     * @returns {Promise<string | undefined>} the public key corresponding to the header key identifier, if available
     */
    private getPublicKey;
    /**
     * Decodes the access token and verifies it against the public key
     * @param {ILogger} logger The logger to use.
     * @param {string} rawAccessToken the raw access token.
     * @param {string} publicKey the public key to verify signature against.
     * @returns {Promise<jwt.JWT | null>} A decoded token if the raw token is well formed and the signature is valid.
     */
    private validateTokenSignature;
}
export {};
