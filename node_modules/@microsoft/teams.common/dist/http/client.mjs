import axios from 'axios';
import { ConsoleLogger } from '../logging';

class Client {
  token;
  name;
  options;
  log;
  http;
  seq = 0;
  interceptors;
  constructor(options = {}) {
    this.options = options;
    this.name = options.name || "http";
    this.token = options.token;
    this.log = options.logger || new ConsoleLogger(this.name);
    this.interceptors = /* @__PURE__ */ new Map();
    this.http = axios.create({
      baseURL: options.baseUrl,
      timeout: options.timeout,
      headers: options.headers
    });
    for (const interceptor of options.interceptors || []) {
      this.use(interceptor);
    }
  }
  async get(url, config) {
    return this.http.get(url, await this.withConfig(config));
  }
  async post(url, data, config) {
    return this.http.post(url, data, await this.withConfig(config));
  }
  async put(url, data, config) {
    return this.http.put(url, data, await this.withConfig(config));
  }
  async patch(url, data, config) {
    return this.http.patch(url, data, await this.withConfig(config));
  }
  async delete(url, config) {
    return this.http.delete(url, await this.withConfig(config));
  }
  async request(config) {
    return this.http.request(await this.withConfig(config));
  }
  /**
   * Register an interceptor to use
   * as middleware for the request/response/error
   */
  use(interceptor) {
    const id = ++this.seq;
    let requestId = void 0;
    let responseId = void 0;
    if (interceptor.request) {
      requestId = this.http.interceptors.request.use(
        /* istanbul ignore next */
        (config) => {
          return interceptor.request({ config, log: this.log });
        },
        /* istanbul ignore next */
        (error) => {
          if (!interceptor.error) return error;
          return interceptor.error({ error, log: this.log });
        }
      );
    }
    if (interceptor.response) {
      responseId = this.http.interceptors.response.use(
        /* istanbul ignore next */
        (res) => {
          return interceptor.response({ res, log: this.log });
        },
        /* istanbul ignore next */
        (error) => {
          if (!interceptor.error) return error;
          return interceptor.error({ error, log: this.log });
        }
      );
    }
    this.interceptors.set(id, {
      requestId,
      responseId,
      interceptor
    });
    return id;
  }
  /**
   * Eject an interceptor
   */
  eject(id) {
    const registry = this.interceptors.get(id);
    if (!registry) return;
    if (registry.requestId) {
      this.http.interceptors.request.eject(registry.requestId);
    }
    if (registry.responseId) {
      this.http.interceptors.response.eject(registry.responseId);
    }
    this.interceptors.delete(id);
  }
  /**
   * Clear (Eject) all interceptors
   */
  clear() {
    for (const id of this.interceptors.keys()) {
      this.eject(id);
    }
  }
  /**
   * Create a copy of the client
   */
  clone(options) {
    return new Client({
      ...this.options,
      ...options,
      headers: {
        ...this.options.headers,
        ...options?.headers
      },
      interceptors: [...Array.from(this.interceptors.values()).map((i) => i.interceptor)]
    });
  }
  async withConfig(config = {}) {
    let token = config.token || this.token;
    if (config.token) {
      delete config.token;
    }
    if (this.options.headers) {
      if (!config.headers) {
        config.headers = {};
      }
      for (const key in this.options.headers) {
        config.headers[key] = this.options.headers[key];
      }
    }
    if (token) {
      if (!config.headers) {
        config.headers = {};
      }
      if (typeof token === "function") {
        token = await token(config);
      }
      if (token && typeof token === "object") {
        token = token.toString();
      }
      config.headers["Authorization"] = `Bearer ${token}`;
    }
    return config;
  }
}

export { Client };
//# sourceMappingURL=client.mjs.map
//# sourceMappingURL=client.mjs.map