class Activity {
  /**
   * Contains the type of the activity.
   */
  type;
  /**
   * Contains an ID that uniquely identifies the activity on the channel.
   */
  id;
  /**
   * Contains the URL that specifies the channel's service endpoint. Set by the channel.
   */
  serviceUrl;
  /**
   * Contains the date and time that the message was sent, in UTC, expressed in ISO-8601 format.
   */
  timestamp;
  /**
   * A locale name for the contents of the text field.
   * The locale name is a combination of an ISO 639 two- or three-letter culture code associated
   * with a language
   * and an ISO 3166 two-letter subculture code associated with a country or region.
   * The locale name can also correspond to a valid BCP-47 language tag.
   */
  locale;
  /**
   * Contains the local date and time of the message, expressed in ISO-8601 format.
   *
   * For example, 2016-09-23T13:07:49.4714686-07:00.
   */
  localTimestamp;
  /**
   * Contains an ID that uniquely identifies the channel. Set by the channel.
   */
  channelId;
  /**
   * Identifies the sender of the message.
   */
  from;
  /**
   * Identifies the conversation to which the activity belongs.
   */
  conversation;
  /**
   * A reference to another conversation or activity.
   */
  relatesTo;
  /**
   * Identifies the recipient of the message.
   */
  recipient;
  /**
   * Contains the ID of the message to which this message is a reply.
   */
  replyToId;
  /**
   * Represents the entities that were mentioned in the message.
   */
  entities;
  /**
   * Contains channel-specific content.
   */
  channelData;
  /**
   * Information about the tenant in which the message was sent.
   */
  get tenant() {
    return this.channelData?.tenant;
  }
  /**
   * Information about the channel in which the message was sent.
   */
  get channel() {
    return this.channelData?.channel;
  }
  /**
   * Information about the team in which the message was sent.
   */
  get team() {
    return this.channelData?.team;
  }
  /**
   * Information about the tenant in which the message was sent.
   */
  get meeting() {
    return this.channelData?.meeting;
  }
  /**
   * Notification settings for the message.
   */
  get notification() {
    return this.channelData?.notification;
  }
  constructor(value) {
    Object.assign(this, {
      channelId: "msteams",
      ...value
    });
  }
  static from(activity) {
    return new Activity(activity);
  }
  toInterface() {
    return Object.assign({}, this);
  }
  clone(options = {}) {
    return new Activity({
      ...this.toInterface(),
      ...options
    });
  }
  withId(value) {
    this.id = value;
    return this;
  }
  withReplyToId(value) {
    this.replyToId = value;
    return this;
  }
  withChannelId(value) {
    this.channelId = value;
    return this;
  }
  withFrom(value) {
    this.from = value;
    return this;
  }
  withConversation(value) {
    this.conversation = value;
    return this;
  }
  withRelatesTo(value) {
    this.relatesTo = value;
    return this;
  }
  withRecipient(value) {
    this.recipient = value;
    return this;
  }
  withServiceUrl(value) {
    this.serviceUrl = value;
    return this;
  }
  withTimestamp(value) {
    this.timestamp = value;
    return this;
  }
  withLocale(value) {
    this.locale = value;
    return this;
  }
  withLocalTimestamp(value) {
    this.localTimestamp = value;
    return this;
  }
  withChannelData(value) {
    this.channelData = { ...this.channelData, ...value };
    return this;
  }
  /**
   * Add an entity.
   */
  addEntity(value) {
    if (!this.entities) {
      this.entities = [];
    }
    this.entities.push(value);
    return this;
  }
  /**
   * Add multiple entities
   */
  addEntities(...value) {
    if (!this.entities) {
      this.entities = [];
    }
    this.entities.push(...value);
    return this;
  }
  /**
   * Add the `Generated By AI` label.
   */
  addAiGenerated() {
    const messageEntity = this.ensureSingleRootLevelMessageEntity();
    if (messageEntity.additionalType?.includes("AIGeneratedContent")) {
      return this;
    }
    if (!messageEntity.additionalType) {
      messageEntity.additionalType = [];
    }
    messageEntity.additionalType.push("AIGeneratedContent");
    return this;
  }
  /**
   * Enable message feedback
   */
  addFeedback() {
    if (!this.channelData) {
      this.channelData = {};
    }
    this.channelData.feedbackLoopEnabled = true;
    return this;
  }
  /**
   * Add citations
   */
  addCitation(position, appearance) {
    const messageEntity = this.ensureSingleRootLevelMessageEntity();
    if (!messageEntity.citation) {
      messageEntity.citation = [];
    }
    messageEntity.citation.push({
      "@type": "Claim",
      position,
      appearance: {
        "@type": "DigitalDocument",
        abstract: appearance.abstract,
        name: appearance.name,
        encodingFormat: "application/vnd.microsoft.card.adaptive",
        image: appearance.icon ? {
          "@type": "ImageObject",
          name: appearance.icon
        } : void 0,
        keywords: appearance.keywords,
        text: appearance.text,
        url: appearance.url,
        usageInfo: appearance.usageInfo
      }
    });
    return this;
  }
  /**
   * is this a streaming activity
   */
  isStreaming() {
    return this.entities?.some((e) => e.type === "streaminfo") || false;
  }
  /**
   * Get or create the base message entity.
   * There should only be one root level message entity.
   */
  ensureSingleRootLevelMessageEntity() {
    let mesageEntity = this.entities?.find(
      (e) => e.type === "https://schema.org/Message" && e["@type"] === "Message"
    );
    if (!mesageEntity) {
      mesageEntity = {
        type: "https://schema.org/Message",
        "@type": "Message",
        "@context": "https://schema.org",
        "@id": ""
      };
      this.addEntity(mesageEntity);
    }
    return mesageEntity;
  }
}

export { Activity };
//# sourceMappingURL=activity.mjs.map
//# sourceMappingURL=activity.mjs.map