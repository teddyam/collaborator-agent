import { cardAttachment } from '../../models';
import { Activity } from '../activity';
import { stripMentionsText } from '../utils';

class MessageActivity extends Activity {
  /**
   * The text content of the message.
   */
  text;
  /**
   * The text to speak.
   */
  speak;
  /**
   * Indicates whether your bot is accepting,
   * expecting, or ignoring user input after the message is delivered to the client. Possible
   * values include: 'acceptingInput', 'ignoringInput', 'expectingInput'
   */
  inputHint;
  /**
   * The text to display if the channel cannot render cards.
   */
  summary;
  /**
   * Format of text fields Default:markdown. Possible values include: 'markdown', 'plain', 'xml'
   */
  textFormat;
  /**
   * The layout hint for multiple attachments. Default: list. Possible values include: 'list',
   * 'carousel'
   */
  attachmentLayout;
  /**
   * Attachments
   */
  attachments;
  /**
   * The suggested actions for the activity.
   */
  suggestedActions;
  /**
   * The importance of the activity. Possible values include: 'low', 'normal', 'high'
   */
  importance;
  /**
   * A delivery hint to signal to the recipient alternate delivery paths for the activity.
   * The default delivery mode is "default". Possible values include: 'normal', 'notification'
   */
  deliveryMode;
  /**
   * The time at which the activity should be considered to be "expired" and should not be
   * presented to the recipient.
   */
  expiration;
  /**
   * A value that is associated with the activity.
   */
  value;
  constructor(text = "", value = {}) {
    super({
      ...value,
      type: "message"
    });
    Object.assign(this, { text, ...value });
  }
  /**
   * initialize from interface
   */
  static from(activity) {
    return new MessageActivity(activity.text, activity);
  }
  /**
   * convert to interface
   */
  toInterface() {
    return Object.assign(
      {
        stripMentionsText: this.stripMentionsText.bind(this),
        isRecipientMentioned: this.isRecipientMentioned.bind(this),
        getAccountMention: this.getAccountMention.bind(this)
      },
      this
    );
  }
  /**
   * copy to a new instance
   */
  clone(options = {}) {
    return new MessageActivity(this.text, {
      ...this.toInterface(),
      ...options
    });
  }
  /**
   * The text content of the message.
   */
  withText(value) {
    this.text = value;
    return this;
  }
  /**
   * The text to speak.
   */
  withSpeak(value) {
    this.speak = value;
    return this;
  }
  /**
   * Indicates whether your bot is accepting,
   * expecting, or ignoring user input after the message is delivered to the client. Possible
   * values include: 'acceptingInput', 'ignoringInput', 'expectingInput'
   */
  withInputHint(value) {
    this.inputHint = value;
    return this;
  }
  /**
   * The text to display if the channel cannot render cards.
   */
  withSummary(value) {
    this.summary = value;
    return this;
  }
  /**
   * Format of text fields Default:markdown. Possible values include: 'markdown', 'plain', 'xml'
   */
  withTextFormat(value) {
    this.textFormat = value;
    return this;
  }
  /**
   * The layout hint for multiple attachments. Default: list. Possible values include: 'list',
   * 'carousel'
   */
  withAttachmentLayout(value) {
    this.attachmentLayout = value;
    return this;
  }
  /**
   * The suggested actions for the activity.
   */
  withSuggestedActions(value) {
    this.suggestedActions = value;
    return this;
  }
  /**
   * The importance of the activity. Possible values include: 'low', 'normal', 'high'
   */
  withImportance(value) {
    this.importance = value;
    return this;
  }
  /**
   * A delivery hint to signal to the recipient alternate delivery paths for the activity.
   * The default delivery mode is "default". Possible values include: 'normal', 'notification'
   */
  withDeliveryMode(value) {
    this.deliveryMode = value;
    return this;
  }
  /**
   * The time at which the activity should be considered to be "expired" and should not be
   * presented to the recipient.
   */
  withExpiration(value) {
    this.expiration = value;
    return this;
  }
  /**
   * Append text
   */
  addText(text) {
    this.text += text;
    return this;
  }
  /**
   * Attachments
   */
  addAttachments(...value) {
    if (!this.attachments) {
      this.attachments = [];
    }
    this.attachments.push(...value);
    return this;
  }
  /**
   * `@mention` an account
   * @param account the account to mention
   * @param options options to customize the mention
   */
  addMention(account, options = {}) {
    const text = options.text || account.name;
    const addText = options.addText ?? true;
    if (addText) {
      this.addText(`<at>${text}</at>`);
    }
    return this.addEntity({
      type: "mention",
      mentioned: account,
      text: `<at>${text}</at>`
    });
  }
  /**
   * Add a card attachment
   */
  addCard(type, content) {
    return this.addAttachments(cardAttachment(type, content));
  }
  /**
   * remove "\<at>...\</at>" text from an activity
   */
  stripMentionsText(options = {}) {
    this.text = stripMentionsText(this, options);
    return this;
  }
  /**
   * is the recipient account mentioned
   */
  isRecipientMentioned() {
    return (this.entities || []).filter((e) => e.type === "mention").some((e) => e.mentioned.id === this.recipient.id);
  }
  /**
   * get a mention by the account id if exists
   */
  getAccountMention(accountId) {
    return (this.entities || []).filter((e) => e.type === "mention").find((e) => e.mentioned.id === accountId);
  }
  /**
   * Add stream info, making
   * this a final stream message
   */
  addStreamFinal() {
    if (!this.channelData) {
      this.channelData = {};
    }
    this.channelData.streamId = this.id;
    this.channelData.streamType = "final";
    return this.addEntity({
      type: "streaminfo",
      streamId: this.id,
      streamType: "final"
    });
  }
}

export { MessageActivity };
//# sourceMappingURL=message.mjs.map
//# sourceMappingURL=message.mjs.map