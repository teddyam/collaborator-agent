'use strict';

var teams_common = require('@microsoft/teams.common');
var localMemory = require('../local-memory');
var templates = require('../templates');

class ChatPrompt {
  get name() {
    return this._name;
  }
  _name;
  get description() {
    return this._description;
  }
  _description;
  get messages() {
    return this._messages;
  }
  _messages;
  get functions() {
    return Object.values(this._functions);
  }
  _functions = {};
  get plugins() {
    return this._plugins;
  }
  _plugins;
  _role;
  _template;
  _model;
  _log;
  constructor(options, plugins) {
    this._name = options.name || "chat";
    this._description = options.description || "an agent you can chat with";
    this._role = options.role || "system";
    this._model = options.model;
    this._template = Array.isArray(options.instructions) ? new templates.StringTemplate(options.instructions.join("\n")) : typeof options.instructions !== "object" ? new templates.StringTemplate(options.instructions) : options.instructions;
    this._messages = typeof options.messages === "object" && !Array.isArray(options.messages) ? options.messages : new localMemory.LocalMemory({ messages: options.messages || [] });
    this._plugins = plugins || [];
    this._log = options.logger || new teams_common.ConsoleLogger(`@microsoft/teams.ai/prompts/${this._name}`);
  }
  use(...args) {
    const prompt = args.length === 1 ? args[0] : args[1];
    const name = args.length === 1 ? prompt.name : args[0];
    this._functions[name] = {
      name,
      description: prompt.description,
      parameters: {
        type: "object",
        properties: {
          text: {
            type: "string",
            description: "the text to send to the assistant"
          }
        },
        required: ["text"]
      },
      handler: ({ text }) => {
        return prompt.send(text);
      }
    };
    return this;
  }
  function(...args) {
    const name = args[0];
    const description = args[1];
    const parameters = args.length === 3 ? null : args[2];
    const handler = args[args.length - 1];
    this._functions[name] = {
      name,
      description,
      parameters: parameters || {},
      handler
    };
    return this;
  }
  usePlugin(name, args) {
    const plugin = this._plugins.find((p) => p.name === name);
    if (!plugin) {
      this._log.debug(`Plugin "${name}" not found`);
      throw new Error(`Plugin "${name}" not found`);
    }
    if (plugin.onUsePlugin) {
      this._log.debug(`Using plugin "${name}" with args:`, args);
      plugin.onUsePlugin(args);
      this._log.debug(`Successfully initialized plugin "${name}"`);
    }
    return this;
  }
  async call(name, args) {
    const fn = this._functions[name];
    if (!fn) {
      throw new Error(`function "${name}" not found`);
    }
    return this.executeFunction(name, fn, args);
  }
  async send(input, options = {}) {
    this._log.debug(`Processing plugins before send (${this.plugins.length} plugins found)`);
    for (const plugin of this.plugins) {
      if (plugin.onBeforeSend) {
        this._log.debug(`Running onBeforeSend for plugin "${plugin.name}"`);
        input = await plugin.onBeforeSend(input);
      }
    }
    const { onChunk } = options;
    if (typeof input === "string") {
      input = input.trim();
    }
    const messages = !Array.isArray(options.messages) ? options.messages || this._messages : new localMemory.LocalMemory({ messages: options.messages || [] });
    let buffer = "";
    let system = void 0;
    let prompt = await this._template.render();
    for (const plugin of this.plugins) {
      if (plugin.onBuildPrompt) {
        const nextPrompt = await plugin.onBuildPrompt(prompt);
        if (nextPrompt != null && nextPrompt !== prompt) {
          this._log.debug(`Plugin "${plugin.name}" modified the system prompt`);
          prompt = nextPrompt;
        }
      }
    }
    if (prompt) {
      system = {
        role: this._role,
        content: prompt
      };
      this._log.debug("System instructions for LLM:", prompt);
    }
    let functions = Object.values(this._functions);
    const pluginsWithOnBuildFunctions = this._plugins.filter(
      (plugin) => plugin.onBuildFunctions != null
    );
    for (const plugin of pluginsWithOnBuildFunctions) {
      functions = await plugin.onBuildFunctions(functions);
    }
    const fnMap = functions.reduce((acc, fn) => {
      acc[fn.name] = {
        ...fn,
        handler: (args) => this.executeFunction(fn.name, fn, args)
      };
      return acc;
    }, {});
    if (Object.keys(fnMap).length > 0) {
      this._log.debug(
        "Available functions for LLM:",
        Object.keys(fnMap).map((name) => {
          const fn = fnMap[name];
          const paramDescriptions = "properties" in fn.parameters && fn.parameters.properties ? Object.entries(
            fn.parameters.properties
          ).reduce(
            (acc, [key, prop]) => ({
              ...acc,
              [key]: prop.description
            }),
            {}
          ) : {};
          return {
            name,
            description: fn.description,
            parameters: {
              schema: fn.parameters,
              descriptions: paramDescriptions
            }
          };
        })
      );
    }
    const res = await this._model.send(
      {
        role: "user",
        content: input
      },
      {
        system,
        messages,
        request: options.request,
        functions: fnMap,
        onChunk: async (chunk) => {
          if (!chunk || !onChunk) return;
          buffer += chunk;
          try {
            await onChunk(buffer);
            buffer = "";
          } catch (err) {
            return;
          }
        }
      }
    );
    let output = {
      ...res,
      content: res.content || ""
    };
    if (output.function_calls && output.function_calls.length > 0) {
      this._log.debug(
        "LLM requested function calls:",
        output.function_calls.map((call) => ({
          name: call.name,
          id: call.id,
          arguments: call.arguments
        }))
      );
    }
    this._log.debug(`Processing plugins after send (${this.plugins.length} plugins found)`);
    for (const plugin of this.plugins) {
      if (plugin.onAfterSend) {
        this._log.debug(`Running onAfterSend for plugin "${plugin.name}"`);
        output = await plugin.onAfterSend(output);
      }
    }
    return output;
  }
  async executeFunction(name, fn, args) {
    const processedArgs = args || {};
    for (const plugin of this.plugins) {
      if (plugin.onBeforeFunctionCall) {
        await plugin.onBeforeFunctionCall(name, processedArgs);
      }
    }
    let result = await fn.handler(processedArgs);
    for (const plugin of this.plugins) {
      if (plugin.onAfterFunctionCall) {
        result = await plugin.onAfterFunctionCall(name, processedArgs, result);
      }
    }
    return result;
  }
}

exports.ChatPrompt = ChatPrompt;
//# sourceMappingURL=chat.js.map
//# sourceMappingURL=chat.js.map